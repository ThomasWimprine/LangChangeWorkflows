{"session_id":"f0d4fbc3-a5b1-443e-8264-7550e32cfe6a","transcript_path":"/home/thomas/.claude/projects/-home-thomas-Repositories-LangChangeWorkflows/f0d4fbc3-a5b1-443e-8264-7550e32cfe6a.jsonl","cwd":"/home/thomas/Repositories/LangChangeWorkflows","permission_mode":"acceptEdits","hook_event_name":"PreToolUse","tool_name":"Write","tool_input":{"file_path":"/home/thomas/Repositories/LangChangeWorkflows/langgraph/workflows/base_prp_workflow.py","content":"\"\"\"\nBase PRP Workflow Implementation\n\nThis module implements the core LangGraph workflow for PRP execution.\nIt provides the foundation for all 6 gates with state management, retry logic,\ncircuit breakers, and cost optimization through context sharing.\n\nThis is the base class that can be extended by project-specific workflows.\n\"\"\"\n\nfrom typing import Dict, Any, Optional, List\nfrom datetime import datetime\nimport logging\n\nfrom langgraph.graph import StateGraph, END\nfrom langgraph.checkpoint.memory import MemorySaver\n\nfrom ..schemas.prp_state import PRPState, ValidationResult, CircuitBreakerState\nfrom ..nodes.gates.gate2_coverage import validate_coverage_gate\nfrom ..utils.context_optimizer import ContextOptimizer\nfrom ..utils.agent_coordinator import AgentCoordinator\nfrom ..utils.state_persistence import StatePersistence\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass BasePRPWorkflow:\n    \"\"\"\n    Base LangGraph workflow for PRP execution.\n\n    Features:\n    - Stateful execution with automatic checkpointing\n    - 6-gate validation with configurable thresholds\n    - Retry logic (3-strike rule per gate)\n    - Circuit breaker (15 consecutive failures)\n    - Context optimization for cost savings\n    - Multi-agent coordination\n\n    Extension Patterns:\n    1. Inheritance: Subclass and override build_graph()\n    2. Configuration: Pass custom config dict\n    3. Plugins: Register custom nodes via add_custom_node()\n    \"\"\"\n\n    def __init__(\n        self,\n        config_path: Optional[str] = None,\n        enable_checkpointing: bool = True,\n        enable_context_optimization: bool = True\n    ):\n        \"\"\"\n        Initialize the base PRP workflow.\n\n        Args:\n            config_path: Path to configuration YAML (optional)\n            enable_checkpointing: Enable state persistence (default: True)\n            enable_context_optimization: Enable cost-saving context sharing (default: True)\n        \"\"\"\n        self.config = self._load_config(config_path)\n        self.enable_checkpointing = enable_checkpointing\n        self.enable_context_optimization = enable_context_optimization\n\n        # Initialize utilities\n        self.context_optimizer = ContextOptimizer() if enable_context_optimization else None\n        self.agent_coordinator = AgentCoordinator()\n        self.state_persistence = StatePersistence()\n\n        # Build the state graph\n        self.graph = self.build_graph()\n\n        # Compile with memory saver for checkpointing\n        if enable_checkpointing:\n            memory = MemorySaver()\n            self.app = self.graph.compile(checkpointer=memory)\n        else:\n            self.app = self.graph.compile()\n\n        logger.info(\"BasePRPWorkflow initialized successfully\")\n\n    def _load_config(self, config_path: Optional[str]) -> Dict[str, Any]:\n        \"\"\"\n        Load configuration from YAML file.\n\n        Falls back to default configuration if path not provided or file not found.\n        \"\"\"\n        if not config_path:\n            return self._default_config()\n\n        try:\n            import yaml\n            from pathlib import Path\n\n            path = Path(config_path)\n            if not path.exists():\n                logger.warning(f\"Config file not found: {config_path}, using defaults\")\n                return self._default_config()\n\n            with open(path, 'r') as f:\n                config = yaml.safe_load(f)\n\n            logger.info(f\"Loaded configuration from {config_path}\")\n            return config\n        except Exception as e:\n            logger.error(f\"Error loading config: {e}, using defaults\")\n            return self._default_config()\n\n    def _default_config(self) -> Dict[str, Any]:\n        \"\"\"\n        Return default configuration for PRP workflow.\n        \"\"\"\n        return {\n            \"max_retries\": 3,\n            \"circuit_breaker_threshold\": 15,\n            \"gates\": {\n                \"gate_1_tdd\": {\"enabled\": True, \"blocking\": True},\n                \"gate_2_coverage\": {\"enabled\": True, \"blocking\": True, \"threshold\": 100},\n                \"gate_3_mock\": {\"enabled\": True, \"blocking\": True},\n                \"gate_4_mutation\": {\"enabled\": True, \"blocking\": True, \"threshold\": 95},\n                \"gate_5_security\": {\"enabled\": True, \"blocking\": True},\n                \"gate_6_production_ready\": {\"enabled\": True, \"blocking\": True}\n            },\n            \"specialist_agents\": {\n                \"gate_1_tdd\": \"test-automation\",\n                \"gate_2_coverage\": \"test-automation\",\n                \"gate_3_mock\": \"python-developer\",  # Language-specific\n                \"gate_4_mutation\": \"test-automation\",\n                \"gate_5_security\": \"security-reviewer\",\n                \"gate_6_production_ready\": \"architect-reviewer\"\n            }\n        }\n\n    def build_graph(self) -> StateGraph:\n        \"\"\"\n        Build the LangGraph state graph for PRP execution.\n\n        This method can be overridden in subclasses to add custom nodes/edges.\n\n        Returns:\n            StateGraph configured with nodes and edges\n        \"\"\"\n        # Create state graph with PRPState schema\n        workflow = StateGraph(PRPState)\n\n        # Add entry point\n        workflow.set_entry_point(\"initialize\")\n\n        # Add initialization node\n        workflow.add_node(\"initialize\", self.initialize_workflow)\n\n        # Phase 0 POC: Only Gate 2 (Coverage) implemented\n        # Full implementation will add all 6 gates\n\n        # Add Gate 2: Coverage validation (POC)\n        if self.config[\"gates\"][\"gate_2_coverage\"][\"enabled\"]:\n            workflow.add_node(\"gate_2_coverage\", self.validate_gate_2)\n\n        # Add failure handling nodes\n        workflow.add_node(\"handle_failure\", self.handle_gate_failure)\n        workflow.add_node(\"check_circuit_breaker\", self.check_circuit_breaker)\n        workflow.add_node(\"consult_specialist\", self.consult_specialist)\n\n        # Add success/completion nodes\n        workflow.add_node(\"workflow_success\", self.complete_workflow)\n        workflow.add_node(\"workflow_failed\", self.fail_workflow)\n\n        # Define edges\n\n        # Initialize -> Gate 2\n        workflow.add_edge(\"initialize\", \"gate_2_coverage\")\n\n        # Gate 2 -> Success or Failure\n        workflow.add_conditional_edges(\n            \"gate_2_coverage\",\n            self.route_gate_result,\n            {\n                \"success\": \"workflow_success\",\n                \"retry\": \"handle_failure\",\n                \"circuit_breaker\": \"check_circuit_breaker\"\n            }\n        )\n\n        # Failure handling\n        workflow.add_conditional_edges(\n            \"handle_failure\",\n            self.route_failure_handling,\n            {\n                \"retry\": \"gate_2_coverage\",\n                \"consult_specialist\": \"consult_specialist\",\n                \"circuit_breaker\": \"check_circuit_breaker\"\n            }\n        )\n\n        # Specialist consultation -> retry gate\n        workflow.add_edge(\"consult_specialist\", \"gate_2_coverage\")\n\n        # Circuit breaker -> workflow failed\n        workflow.add_edge(\"check_circuit_breaker\", \"workflow_failed\")\n\n        # Terminal nodes\n        workflow.add_edge(\"workflow_success\", END)\n        workflow.add_edge(\"workflow_failed\", END)\n\n        return workflow\n\n    # Node implementations\n\n    def initialize_workflow(self, state: PRPState) -> PRPState:\n        \"\"\"\n        Initialize the PRP workflow state.\n\n        Sets up tracking, cost monitoring, and workflow metadata.\n        \"\"\"\n        logger.info(f\"Initializing workflow for PRP: {state.get('prp_file', 'unknown')}\")\n\n        return {\n            **state,\n            \"workflow_id\": state.get(\"workflow_id\") or self._generate_workflow_id(),\n            \"started_at\": datetime.now(),\n            \"phase\": \"execute\",\n            \"gates_passed\": [],\n            \"gates_failed\": {},\n            \"consecutive_failures\": 0,\n            \"circuit_breaker_active\": False,\n            \"tdd_cycle\": \"red\",  # Start with RED phase\n            \"cost_tracking\": {},\n            \"token_usage\": {},\n            \"api_calls\": 0,\n            \"cache_hits\": 0,\n            \"active_agents\": [],\n            \"agent_results\": {},\n            \"max_retries\": self.config[\"max_retries\"],\n            \"circuit_breaker_threshold\": self.config[\"circuit_breaker_threshold\"]\n        }\n\n    def validate_gate_2(self, state: PRPState) -> PRPState:\n        \"\"\"\n        Validate Gate 2: Test Coverage (100% requirement).\n\n        This is the Phase 0 POC gate implementation.\n        \"\"\"\n        logger.info(\"Validating Gate 2: Test Coverage\")\n\n        gate_id = \"gate_2_coverage\"\n        retry_count = state.get(\"gates_failed\", {}).get(gate_id, 0)\n\n        # Call the actual gate validation logic\n        result = validate_coverage_gate(\n            state=state,\n            config=self.config[\"gates\"][\"gate_2_coverage\"],\n            context_optimizer=self.context_optimizer\n        )\n\n        # Update state based on validation result\n        new_state = {**state}\n\n        if result[\"passed\"]:\n            # Gate passed\n            new_state[\"gates_passed\"] = state.get(\"gates_passed\", []) + [gate_id]\n            new_state[\"consecutive_failures\"] = 0\n            logger.info(f\"Gate 2 PASSED - Coverage: {result['details'].get('coverage_percentage', 0)}%\")\n        else:\n            # Gate failed\n            gates_failed = state.get(\"gates_failed\", {})\n            gates_failed[gate_id] = retry_count + 1\n            new_state[\"gates_failed\"] = gates_failed\n            new_state[\"consecutive_failures\"] = state.get(\"consecutive_failures\", 0) + 1\n            logger.warning(f\"Gate 2 FAILED - Retry {retry_count + 1}/{self.config['max_retries']}\")\n\n        # Track costs\n        new_state[\"cost_tracking\"] = {\n            **state.get(\"cost_tracking\", {}),\n            gate_id: result[\"cost\"]\n        }\n        new_state[\"token_usage\"] = {\n            **state.get(\"token_usage\", {}),\n            gate_id: result[\"tokens_used\"]\n        }\n        new_state[\"api_calls\"] = state.get(\"api_calls\", 0) + 1\n\n        # Store validation result\n        new_state[\"current_gate\"] = gate_id\n        new_state[\"current_validation_result\"] = result\n\n        return new_state\n\n    def handle_gate_failure(self, state: PRPState) -> PRPState:\n        \"\"\"\n        Handle gate validation failure.\n\n        Implements 3-strike rule and determines next action.\n        \"\"\"\n        gate_id = state.get(\"current_gate\")\n        retry_count = state.get(\"gates_failed\", {}).get(gate_id, 0)\n\n        logger.info(f\"Handling failure for {gate_id} - Retry {retry_count}/{self.config['max_retries']}\")\n\n        return {\n            **state,\n            \"failure_history\": state.get(\"failure_history\", []) + [{\n                \"gate\": gate_id,\n                \"retry_count\": retry_count,\n                \"timestamp\": datetime.now().isoformat(),\n                \"message\": state.get(\"current_validation_result\", {}).get(\"message\", \"\")\n            }]\n        }\n\n    def check_circuit_breaker(self, state: PRPState) -> PRPState:\n        \"\"\"\n        Check and activate circuit breaker if threshold exceeded.\n        \"\"\"\n        consecutive = state.get(\"consecutive_failures\", 0)\n        threshold = state.get(\"circuit_breaker_threshold\", 15)\n\n        if consecutive >= threshold:\n            logger.error(f\"Circuit breaker activated: {consecutive} consecutive failures\")\n            return {\n                **state,\n                \"circuit_breaker_active\": True,\n                \"workflow_status\": \"circuit_breaker_activated\"\n            }\n\n        return state\n\n    def consult_specialist(self, state: PRPState) -> PRPState:\n        \"\"\"\n        Consult specialist agent after 3 failed attempts.\n        \"\"\"\n        gate_id = state.get(\"current_gate\")\n        specialist = self.config[\"specialist_agents\"].get(gate_id, \"test-automation\")\n\n        logger.info(f\"Consulting specialist agent: {specialist} for {gate_id}\")\n\n        # Use agent coordinator to consult specialist\n        specialist_guidance = self.agent_coordinator.consult_specialist(\n            gate_id=gate_id,\n            specialist_agent=specialist,\n            failure_context=state.get(\"current_validation_result\", {}),\n            state=state\n        )\n\n        return {\n            **state,\n            \"specialist_consultations\": state.get(\"specialist_consultations\", []) + [specialist],\n            \"specialist_guidance\": specialist_guidance\n        }\n\n    def complete_workflow(self, state: PRPState) -> PRPState:\n        \"\"\"\n        Complete the workflow successfully.\n        \"\"\"\n        logger.info(\"Workflow completed successfully!\")\n\n        return {\n            **state,\n            \"workflow_status\": \"completed\",\n            \"completed_at\": datetime.now().isoformat()\n        }\n\n    def fail_workflow(self, state: PRPState) -> PRPState:\n        \"\"\"\n        Mark workflow as failed.\n        \"\"\"\n        logger.error(\"Workflow failed - circuit breaker activated\")\n\n        return {\n            **state,\n            \"workflow_status\": \"failed\",\n            \"failed_at\": datetime.now().isoformat(),\n            \"failure_reason\": \"circuit_breaker_activated\"\n        }\n\n    # Routing functions\n\n    def route_gate_result(self, state: PRPState) -> str:\n        \"\"\"\n        Route based on gate validation result.\n\n        Returns:\n            \"success\" if gate passed\n            \"retry\" if gate failed but retries remain\n            \"circuit_breaker\" if consecutive failures exceed threshold\n        \"\"\"\n        result = state.get(\"current_validation_result\", {})\n        gate_id = state.get(\"current_gate\")\n        retry_count = state.get(\"gates_failed\", {}).get(gate_id, 0)\n        consecutive = state.get(\"consecutive_failures\", 0)\n\n        # Check circuit breaker first\n        if consecutive >= state.get(\"circuit_breaker_threshold\", 15):\n            return \"circuit_breaker\"\n\n        # Check if gate passed\n        if result.get(\"passed\", False):\n            return \"success\"\n\n        # Gate failed - check if retries remain\n        return \"retry\"\n\n    def route_failure_handling(self, state: PRPState) -> str:\n        \"\"\"\n        Route failure handling based on retry count.\n\n        Returns:\n            \"retry\" if retries remain (< 3)\n            \"consult_specialist\" if at 3-strike threshold\n            \"circuit_breaker\" if consecutive failures >= 15\n        \"\"\"\n        gate_id = state.get(\"current_gate\")\n        retry_count = state.get(\"gates_failed\", {}).get(gate_id, 0)\n        consecutive = state.get(\"consecutive_failures\", 0)\n        max_retries = state.get(\"max_retries\", 3)\n\n        # Check circuit breaker\n        if consecutive >= state.get(\"circuit_breaker_threshold\", 15):\n            return \"circuit_breaker\"\n\n        # Check if we need specialist consultation (3-strike rule)\n        if retry_count >= max_retries:\n            return \"consult_specialist\"\n\n        # Normal retry\n        return \"retry\"\n\n    def _generate_workflow_id(self) -> str:\n        \"\"\"\n        Generate unique workflow ID.\n        \"\"\"\n        import uuid\n        return f\"prp-{datetime.now().strftime('%Y%m%d-%H%M%S')}-{str(uuid.uuid4())[:8]}\"\n\n    # Public API\n\n    def execute(\n        self,\n        prp_file: str,\n        initial_state: Optional[Dict[str, Any]] = None\n    ) -> PRPState:\n        \"\"\"\n        Execute the PRP workflow.\n\n        Args:\n            prp_file: Path to PRP file to execute\n            initial_state: Optional initial state overrides\n\n        Returns:\n            Final PRPState after workflow completion\n        \"\"\"\n        logger.info(f\"Starting PRP workflow execution for: {prp_file}\")\n\n        # Build initial state\n        state: PRPState = {\n            \"prp_file\": prp_file,\n            \"phase\": \"execute\",\n            \"workflow_id\": self._generate_workflow_id(),\n            \"started_at\": datetime.now(),\n            **(initial_state or {})\n        }\n\n        # Execute workflow\n        config = {\"configurable\": {\"thread_id\": state[\"workflow_id\"]}}\n\n        result = self.app.invoke(state, config)\n\n        # Persist final state\n        self.state_persistence.save_state(result)\n\n        logger.info(f\"Workflow execution completed with status: {result.get('workflow_status', 'unknown')}\")\n\n        return result\n\n    def stream_execute(\n        self,\n        prp_file: str,\n        initial_state: Optional[Dict[str, Any]] = None\n    ):\n        \"\"\"\n        Execute workflow with streaming updates.\n\n        Yields state updates as the workflow progresses.\n        \"\"\"\n        logger.info(f\"Starting streaming PRP workflow execution for: {prp_file}\")\n\n        state: PRPState = {\n            \"prp_file\": prp_file,\n            \"phase\": \"execute\",\n            \"workflow_id\": self._generate_workflow_id(),\n            \"started_at\": datetime.now(),\n            **(initial_state or {})\n        }\n\n        config = {\"configurable\": {\"thread_id\": state[\"workflow_id\"]}}\n\n        for update in self.app.stream(state, config):\n            yield update\n\n    def add_custom_node(\n        self,\n        node_id: str,\n        node_func: callable,\n        after_node: Optional[str] = None\n    ):\n        \"\"\"\n        Add a custom node to the workflow (plugin pattern).\n\n        Args:\n            node_id: Unique identifier for the node\n            node_func: Callable that takes PRPState and returns PRPState\n            after_node: Optional node to insert after\n        \"\"\"\n        # Note: This requires rebuilding the graph\n        # In production, this would be handled more elegantly\n        logger.warning(\"add_custom_node requires graph rebuild - use with caution\")\n        raise NotImplementedError(\"Custom node addition requires graph rebuild\")\n"}}
