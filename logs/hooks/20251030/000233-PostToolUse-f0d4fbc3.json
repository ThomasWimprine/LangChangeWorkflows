{"session_id":"f0d4fbc3-a5b1-443e-8264-7550e32cfe6a","transcript_path":"/home/thomas/.claude/projects/-home-thomas-Repositories-LangChangeWorkflows/f0d4fbc3-a5b1-443e-8264-7550e32cfe6a.jsonl","cwd":"/home/thomas/Repositories/LangChangeWorkflows","permission_mode":"acceptEdits","hook_event_name":"PostToolUse","tool_name":"Write","tool_input":{"file_path":"/home/thomas/Repositories/LangChangeWorkflows/langgraph/utils/agent_coordinator.py","content":"\"\"\"\nAgent Coordinator\n\nCoordinates multi-agent operations for PRP workflow.\nHandles specialist consultations, agent selection, and result aggregation.\n\nKey Features:\n- Consult specialist agents after 3-strike rule\n- Coordinate multiple agents for complex tasks\n- Aggregate agent responses for consensus\n- Track agent performance and selection\n\"\"\"\n\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom pathlib import Path\nimport os\n\nlogger = logging.getLogger(__name__)\n\n\nclass AgentCoordinator:\n    \"\"\"\n    Coordinates multi-agent operations in PRP workflow.\n\n    Responsibilities:\n    - Select appropriate specialist agents\n    - Consult agents for guidance\n    - Aggregate multiple agent responses\n    - Track agent effectiveness\n    \"\"\"\n\n    def __init__(self, agent_registry_path: Optional[Path] = None):\n        \"\"\"\n        Initialize agent coordinator.\n\n        Args:\n            agent_registry_path: Path to agent registry (default: ~/.claude/agents)\n        \"\"\"\n        self.agent_registry_path = agent_registry_path or Path.home() / \".claude\" / \"agents\"\n        self.agent_consultations = []\n\n        logger.info(f\"AgentCoordinator initialized with registry: {self.agent_registry_path}\")\n\n    def consult_specialist(\n        self,\n        gate_id: str,\n        specialist_agent: str,\n        failure_context: Dict[str, Any],\n        state: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Consult specialist agent for guidance after gate failure.\n\n        Args:\n            gate_id: Gate that failed\n            specialist_agent: Specialist agent to consult\n            failure_context: Validation failure details\n            state: Current workflow state\n\n        Returns:\n            Specialist guidance including remediation steps\n        \"\"\"\n        logger.info(f\"Consulting specialist {specialist_agent} for {gate_id}\")\n\n        # Load specialist agent prompt\n        agent_prompt = self._load_agent_prompt(specialist_agent)\n\n        # Build consultation context\n        context = self._build_consultation_context(\n            gate_id=gate_id,\n            failure_context=failure_context,\n            state=state\n        )\n\n        # TODO: Call Claude API with specialist agent\n        # For now, return simulated guidance\n\n        guidance = {\n            \"specialist\": specialist_agent,\n            \"gate\": gate_id,\n            \"consulted_at\": \"2025-10-29T00:00:00\",\n            \"remediation_steps\": self._get_remediation_steps(gate_id, failure_context),\n            \"estimated_effort\": \"M\",\n            \"success_probability\": 0.8\n        }\n\n        # Track consultation\n        self.agent_consultations.append({\n            \"agent\": specialist_agent,\n            \"gate\": gate_id,\n            \"timestamp\": guidance[\"consulted_at\"]\n        })\n\n        logger.info(f\"Specialist consultation complete: {len(guidance['remediation_steps'])} steps suggested\")\n\n        return guidance\n\n    def coordinate_multiple_agents(\n        self,\n        agent_ids: List[str],\n        task_description: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Coordinate multiple agents for complex task (e.g., generate-prp phase).\n\n        Args:\n            agent_ids: List of agent identifiers\n            task_description: Task to perform\n            context: Shared context for all agents\n\n        Returns:\n            Aggregated results from all agents\n        \"\"\"\n        logger.info(f\"Coordinating {len(agent_ids)} agents for task\")\n\n        results = {}\n\n        for agent_id in agent_ids:\n            logger.debug(f\"Consulting agent: {agent_id}\")\n\n            # TODO: Call agent via Claude API\n            # For now, return simulated result\n            results[agent_id] = {\n                \"agent\": agent_id,\n                \"status\": \"completed\",\n                \"recommendations\": []\n            }\n\n        # Aggregate results\n        aggregated = self._aggregate_agent_results(results)\n\n        return aggregated\n\n    def _load_agent_prompt(self, agent_id: str) -> str:\n        \"\"\"\n        Load agent system prompt from registry.\n\n        Args:\n            agent_id: Agent identifier\n\n        Returns:\n            Agent system prompt text\n        \"\"\"\n        agent_file = self.agent_registry_path / f\"{agent_id}.md\"\n\n        if not agent_file.exists():\n            logger.warning(f\"Agent not found in registry: {agent_id}\")\n            return f\"You are {agent_id}, a specialist agent.\"\n\n        try:\n            with open(agent_file, 'r') as f:\n                return f.read()\n        except Exception as e:\n            logger.error(f\"Error loading agent prompt: {e}\")\n            return f\"You are {agent_id}, a specialist agent.\"\n\n    def _build_consultation_context(\n        self,\n        gate_id: str,\n        failure_context: Dict[str, Any],\n        state: Dict[str, Any]\n    ) -> str:\n        \"\"\"\n        Build context for specialist consultation.\n\n        Args:\n            gate_id: Failed gate\n            failure_context: Failure details\n            state: Workflow state\n\n        Returns:\n            Formatted context string\n        \"\"\"\n        context_parts = [\n            f\"## Gate Failure Context\\n\",\n            f\"**Gate**: {gate_id}\",\n            f\"**Retry Count**: {failure_context.get('retry_count', 0)}\",\n            f\"**Failure Message**: {failure_context.get('message', 'Unknown')}\",\n            f\"\\n## Failure Details\\n\"\n        ]\n\n        # Add gate-specific details\n        details = failure_context.get(\"details\", {})\n        for key, value in details.items():\n            context_parts.append(f\"- **{key}**: {value}\")\n\n        # Add suggested actions if available\n        suggested_actions = failure_context.get(\"suggested_actions\", [])\n        if suggested_actions:\n            context_parts.append(\"\\n## Automated Suggestions\\n\")\n            for action in suggested_actions:\n                context_parts.append(f\"- {action}\")\n\n        return \"\\n\".join(context_parts)\n\n    def _get_remediation_steps(\n        self,\n        gate_id: str,\n        failure_context: Dict[str, Any]\n    ) -> List[str]:\n        \"\"\"\n        Generate remediation steps based on gate failure.\n\n        Args:\n            gate_id: Failed gate\n            failure_context: Failure details\n\n        Returns:\n            List of actionable remediation steps\n        \"\"\"\n        # Gate-specific remediation\n        if gate_id == \"gate_2_coverage\":\n            details = failure_context.get(\"details\", {})\n            uncovered_files = details.get(\"uncovered_files\", [])\n\n            steps = [\n                \"Run coverage analysis to identify gaps: pytest --cov=. --cov-report=html\",\n                \"Review coverage report in htmlcov/index.html\"\n            ]\n\n            if uncovered_files:\n                steps.append(f\"Add tests for uncovered files: {', '.join(uncovered_files[:3])}\")\n\n            steps.extend([\n                \"Ensure all edge cases are tested\",\n                \"Add integration tests for missing coverage\",\n                \"Re-run coverage validation\"\n            ])\n\n            return steps\n\n        # Default remediation\n        return [\n            \"Review gate validation failure details\",\n            \"Consult gate-specific documentation\",\n            \"Fix identified issues\",\n            \"Re-run gate validation\"\n        ]\n\n    def _aggregate_agent_results(\n        self,\n        results: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Aggregate results from multiple agents.\n\n        Args:\n            results: Dict of agent_id -> result\n\n        Returns:\n            Aggregated results with consensus\n        \"\"\"\n        aggregated = {\n            \"agents_consulted\": list(results.keys()),\n            \"total_agents\": len(results),\n            \"consensus_achieved\": True,  # TODO: Implement consensus logic\n            \"aggregated_recommendations\": [],\n            \"conflicts\": []\n        }\n\n        # Simple aggregation for now\n        for agent_id, result in results.items():\n            recommendations = result.get(\"recommendations\", [])\n            aggregated[\"aggregated_recommendations\"].extend(recommendations)\n\n        return aggregated\n\n    def get_consultation_history(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get history of agent consultations.\n\n        Returns:\n            List of consultation records\n        \"\"\"\n        return self.agent_consultations.copy()\n"},"tool_response":{"type":"create","filePath":"/home/thomas/Repositories/LangChangeWorkflows/langgraph/utils/agent_coordinator.py","content":"\"\"\"\nAgent Coordinator\n\nCoordinates multi-agent operations for PRP workflow.\nHandles specialist consultations, agent selection, and result aggregation.\n\nKey Features:\n- Consult specialist agents after 3-strike rule\n- Coordinate multiple agents for complex tasks\n- Aggregate agent responses for consensus\n- Track agent performance and selection\n\"\"\"\n\nimport logging\nfrom typing import Dict, Any, List, Optional\nfrom pathlib import Path\nimport os\n\nlogger = logging.getLogger(__name__)\n\n\nclass AgentCoordinator:\n    \"\"\"\n    Coordinates multi-agent operations in PRP workflow.\n\n    Responsibilities:\n    - Select appropriate specialist agents\n    - Consult agents for guidance\n    - Aggregate multiple agent responses\n    - Track agent effectiveness\n    \"\"\"\n\n    def __init__(self, agent_registry_path: Optional[Path] = None):\n        \"\"\"\n        Initialize agent coordinator.\n\n        Args:\n            agent_registry_path: Path to agent registry (default: ~/.claude/agents)\n        \"\"\"\n        self.agent_registry_path = agent_registry_path or Path.home() / \".claude\" / \"agents\"\n        self.agent_consultations = []\n\n        logger.info(f\"AgentCoordinator initialized with registry: {self.agent_registry_path}\")\n\n    def consult_specialist(\n        self,\n        gate_id: str,\n        specialist_agent: str,\n        failure_context: Dict[str, Any],\n        state: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Consult specialist agent for guidance after gate failure.\n\n        Args:\n            gate_id: Gate that failed\n            specialist_agent: Specialist agent to consult\n            failure_context: Validation failure details\n            state: Current workflow state\n\n        Returns:\n            Specialist guidance including remediation steps\n        \"\"\"\n        logger.info(f\"Consulting specialist {specialist_agent} for {gate_id}\")\n\n        # Load specialist agent prompt\n        agent_prompt = self._load_agent_prompt(specialist_agent)\n\n        # Build consultation context\n        context = self._build_consultation_context(\n            gate_id=gate_id,\n            failure_context=failure_context,\n            state=state\n        )\n\n        # TODO: Call Claude API with specialist agent\n        # For now, return simulated guidance\n\n        guidance = {\n            \"specialist\": specialist_agent,\n            \"gate\": gate_id,\n            \"consulted_at\": \"2025-10-29T00:00:00\",\n            \"remediation_steps\": self._get_remediation_steps(gate_id, failure_context),\n            \"estimated_effort\": \"M\",\n            \"success_probability\": 0.8\n        }\n\n        # Track consultation\n        self.agent_consultations.append({\n            \"agent\": specialist_agent,\n            \"gate\": gate_id,\n            \"timestamp\": guidance[\"consulted_at\"]\n        })\n\n        logger.info(f\"Specialist consultation complete: {len(guidance['remediation_steps'])} steps suggested\")\n\n        return guidance\n\n    def coordinate_multiple_agents(\n        self,\n        agent_ids: List[str],\n        task_description: str,\n        context: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Coordinate multiple agents for complex task (e.g., generate-prp phase).\n\n        Args:\n            agent_ids: List of agent identifiers\n            task_description: Task to perform\n            context: Shared context for all agents\n\n        Returns:\n            Aggregated results from all agents\n        \"\"\"\n        logger.info(f\"Coordinating {len(agent_ids)} agents for task\")\n\n        results = {}\n\n        for agent_id in agent_ids:\n            logger.debug(f\"Consulting agent: {agent_id}\")\n\n            # TODO: Call agent via Claude API\n            # For now, return simulated result\n            results[agent_id] = {\n                \"agent\": agent_id,\n                \"status\": \"completed\",\n                \"recommendations\": []\n            }\n\n        # Aggregate results\n        aggregated = self._aggregate_agent_results(results)\n\n        return aggregated\n\n    def _load_agent_prompt(self, agent_id: str) -> str:\n        \"\"\"\n        Load agent system prompt from registry.\n\n        Args:\n            agent_id: Agent identifier\n\n        Returns:\n            Agent system prompt text\n        \"\"\"\n        agent_file = self.agent_registry_path / f\"{agent_id}.md\"\n\n        if not agent_file.exists():\n            logger.warning(f\"Agent not found in registry: {agent_id}\")\n            return f\"You are {agent_id}, a specialist agent.\"\n\n        try:\n            with open(agent_file, 'r') as f:\n                return f.read()\n        except Exception as e:\n            logger.error(f\"Error loading agent prompt: {e}\")\n            return f\"You are {agent_id}, a specialist agent.\"\n\n    def _build_consultation_context(\n        self,\n        gate_id: str,\n        failure_context: Dict[str, Any],\n        state: Dict[str, Any]\n    ) -> str:\n        \"\"\"\n        Build context for specialist consultation.\n\n        Args:\n            gate_id: Failed gate\n            failure_context: Failure details\n            state: Workflow state\n\n        Returns:\n            Formatted context string\n        \"\"\"\n        context_parts = [\n            f\"## Gate Failure Context\\n\",\n            f\"**Gate**: {gate_id}\",\n            f\"**Retry Count**: {failure_context.get('retry_count', 0)}\",\n            f\"**Failure Message**: {failure_context.get('message', 'Unknown')}\",\n            f\"\\n## Failure Details\\n\"\n        ]\n\n        # Add gate-specific details\n        details = failure_context.get(\"details\", {})\n        for key, value in details.items():\n            context_parts.append(f\"- **{key}**: {value}\")\n\n        # Add suggested actions if available\n        suggested_actions = failure_context.get(\"suggested_actions\", [])\n        if suggested_actions:\n            context_parts.append(\"\\n## Automated Suggestions\\n\")\n            for action in suggested_actions:\n                context_parts.append(f\"- {action}\")\n\n        return \"\\n\".join(context_parts)\n\n    def _get_remediation_steps(\n        self,\n        gate_id: str,\n        failure_context: Dict[str, Any]\n    ) -> List[str]:\n        \"\"\"\n        Generate remediation steps based on gate failure.\n\n        Args:\n            gate_id: Failed gate\n            failure_context: Failure details\n\n        Returns:\n            List of actionable remediation steps\n        \"\"\"\n        # Gate-specific remediation\n        if gate_id == \"gate_2_coverage\":\n            details = failure_context.get(\"details\", {})\n            uncovered_files = details.get(\"uncovered_files\", [])\n\n            steps = [\n                \"Run coverage analysis to identify gaps: pytest --cov=. --cov-report=html\",\n                \"Review coverage report in htmlcov/index.html\"\n            ]\n\n            if uncovered_files:\n                steps.append(f\"Add tests for uncovered files: {', '.join(uncovered_files[:3])}\")\n\n            steps.extend([\n                \"Ensure all edge cases are tested\",\n                \"Add integration tests for missing coverage\",\n                \"Re-run coverage validation\"\n            ])\n\n            return steps\n\n        # Default remediation\n        return [\n            \"Review gate validation failure details\",\n            \"Consult gate-specific documentation\",\n            \"Fix identified issues\",\n            \"Re-run gate validation\"\n        ]\n\n    def _aggregate_agent_results(\n        self,\n        results: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Aggregate results from multiple agents.\n\n        Args:\n            results: Dict of agent_id -> result\n\n        Returns:\n            Aggregated results with consensus\n        \"\"\"\n        aggregated = {\n            \"agents_consulted\": list(results.keys()),\n            \"total_agents\": len(results),\n            \"consensus_achieved\": True,  # TODO: Implement consensus logic\n            \"aggregated_recommendations\": [],\n            \"conflicts\": []\n        }\n\n        # Simple aggregation for now\n        for agent_id, result in results.items():\n            recommendations = result.get(\"recommendations\", [])\n            aggregated[\"aggregated_recommendations\"].extend(recommendations)\n\n        return aggregated\n\n    def get_consultation_history(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get history of agent consultations.\n\n        Returns:\n            List of consultation records\n        \"\"\"\n        return self.agent_consultations.copy()\n","structuredPatch":[]}}
