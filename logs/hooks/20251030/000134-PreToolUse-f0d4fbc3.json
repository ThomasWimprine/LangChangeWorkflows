{"session_id":"f0d4fbc3-a5b1-443e-8264-7550e32cfe6a","transcript_path":"/home/thomas/.claude/projects/-home-thomas-Repositories-LangChangeWorkflows/f0d4fbc3-a5b1-443e-8264-7550e32cfe6a.jsonl","cwd":"/home/thomas/Repositories/LangChangeWorkflows","permission_mode":"acceptEdits","hook_event_name":"PreToolUse","tool_name":"Write","tool_input":{"file_path":"/home/thomas/Repositories/LangChangeWorkflows/langgraph/nodes/gates/gate2_coverage.py","content":"\"\"\"\nGate 2: Test Coverage Validation\n\nValidates that code has 100% test coverage (lines, branches, functions, statements).\nThis is the Phase 0 POC implementation for LangGraph PRP workflow.\n\nCost Optimization:\n- Uses cached context from previous validations\n- Shares test results across retries\n- Tracks token usage for cost analysis\n\"\"\"\n\nimport logging\nimport subprocess\nimport json\nfrom typing import Dict, Any, Optional\nfrom pathlib import Path\nfrom datetime import datetime\n\nfrom ...schemas.prp_state import ValidationResult\n\nlogger = logging.getLogger(__name__)\n\n\ndef validate_coverage_gate(\n    state: Dict[str, Any],\n    config: Dict[str, Any],\n    context_optimizer: Optional[Any] = None\n) -> ValidationResult:\n    \"\"\"\n    Validate 100% test coverage requirement.\n\n    Args:\n        state: Current workflow state\n        config: Gate configuration (threshold, etc.)\n        context_optimizer: Optional context optimizer for cost savings\n\n    Returns:\n        ValidationResult with pass/fail status and details\n    \"\"\"\n    gate_id = \"gate_2_coverage\"\n    threshold = config.get(\"threshold\", 100)\n    retry_count = state.get(\"gates_failed\", {}).get(gate_id, 0)\n\n    logger.info(f\"Running Gate 2: Coverage validation (threshold: {threshold}%)\")\n\n    start_time = datetime.now()\n\n    try:\n        # Run coverage analysis\n        coverage_result = _run_coverage_analysis(\n            project_path=Path(state.get(\"project_path\", \".\")),\n            cached_context=_get_cached_context(state, context_optimizer)\n        )\n\n        # Check if coverage meets threshold\n        passed = coverage_result[\"coverage_percentage\"] >= threshold\n\n        # Calculate cost (simulated for POC)\n        cost, tokens = _calculate_cost(coverage_result, context_optimizer)\n\n        # Build validation result\n        result: ValidationResult = {\n            \"gate_id\": gate_id,\n            \"passed\": passed,\n            \"message\": _build_message(passed, coverage_result, threshold),\n            \"details\": coverage_result,\n            \"retry_count\": retry_count,\n            \"timestamp\": datetime.now(),\n            \"cost\": cost,\n            \"tokens_used\": tokens,\n            \"suggested_actions\": _suggest_actions(coverage_result) if not passed else None,\n            \"specialist_required\": retry_count >= 3,\n            \"specialist_agent\": \"test-automation\" if retry_count >= 3 else None\n        }\n\n        duration = (datetime.now() - start_time).total_seconds()\n        logger.info(f\"Gate 2 validation completed in {duration:.2f}s - {'PASSED' if passed else 'FAILED'}\")\n\n        return result\n\n    except Exception as e:\n        logger.error(f\"Gate 2 validation error: {e}\")\n        return _error_result(gate_id, str(e), retry_count)\n\n\ndef _run_coverage_analysis(\n    project_path: Path,\n    cached_context: Optional[Dict[str, Any]] = None\n) -> Dict[str, Any]:\n    \"\"\"\n    Run coverage analysis using pytest-cov or similar tool.\n\n    Returns dict with:\n    - coverage_percentage: float\n    - lines_covered: int\n    - lines_total: int\n    - branches_covered: int\n    - branches_total: int\n    - uncovered_files: List[str]\n    - uncovered_lines: Dict[str, List[int]]\n    \"\"\"\n    logger.debug(\"Running coverage analysis...\")\n\n    # Check if we can use cached results\n    if cached_context and _is_cache_valid(cached_context):\n        logger.info(\"Using cached coverage results (cost optimization)\")\n        return cached_context[\"coverage_data\"]\n\n    try:\n        # Run pytest with coverage\n        cmd = [\n            \"pytest\",\n            \"--cov=.\",\n            \"--cov-report=json\",\n            \"--cov-report=term-missing\",\n            \"-v\"\n        ]\n\n        result = subprocess.run(\n            cmd,\n            cwd=project_path,\n            capture_output=True,\n            text=True,\n            timeout=300  # 5 minute timeout\n        )\n\n        # Parse coverage.json output\n        coverage_file = project_path / \"coverage.json\"\n\n        if not coverage_file.exists():\n            logger.warning(\"coverage.json not found, parsing terminal output\")\n            return _parse_coverage_from_output(result.stdout)\n\n        with open(coverage_file, 'r') as f:\n            coverage_data = json.load(f)\n\n        return _parse_coverage_json(coverage_data)\n\n    except subprocess.TimeoutExpired:\n        logger.error(\"Coverage analysis timed out\")\n        return _coverage_timeout_result()\n    except FileNotFoundError:\n        logger.error(\"pytest not found - ensure pytest-cov is installed\")\n        return _coverage_missing_tool_result()\n    except Exception as e:\n        logger.error(f\"Coverage analysis failed: {e}\")\n        return _coverage_error_result(str(e))\n\n\ndef _parse_coverage_json(data: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Parse coverage.json format into standardized result.\n    \"\"\"\n    totals = data.get(\"totals\", {})\n\n    coverage_percentage = totals.get(\"percent_covered\", 0.0)\n    lines_total = totals.get(\"num_statements\", 0)\n    lines_covered = totals.get(\"covered_lines\", 0)\n    branches_total = totals.get(\"num_branches\", 0)\n    branches_covered = totals.get(\"covered_branches\", 0)\n\n    # Find uncovered files and lines\n    uncovered_files = []\n    uncovered_lines = {}\n\n    for filepath, file_data in data.get(\"files\", {}).items():\n        file_coverage = file_data.get(\"summary\", {}).get(\"percent_covered\", 100)\n        if file_coverage < 100:\n            uncovered_files.append(filepath)\n            missing_lines = file_data.get(\"missing_lines\", [])\n            if missing_lines:\n                uncovered_lines[filepath] = missing_lines\n\n    return {\n        \"coverage_percentage\": round(coverage_percentage, 2),\n        \"lines_covered\": lines_covered,\n        \"lines_total\": lines_total,\n        \"branches_covered\": branches_covered,\n        \"branches_total\": branches_total,\n        \"uncovered_files\": uncovered_files[:10],  # Limit to 10 for readability\n        \"uncovered_lines\": uncovered_lines,\n        \"analysis_method\": \"pytest-cov-json\"\n    }\n\n\ndef _parse_coverage_from_output(output: str) -> Dict[str, Any]:\n    \"\"\"\n    Parse coverage from pytest terminal output (fallback).\n    \"\"\"\n    import re\n\n    # Try to extract percentage from output like \"TOTAL ... 98%\"\n    match = re.search(r\"TOTAL.*?(\\d+)%\", output)\n\n    if match:\n        percentage = float(match.group(1))\n        return {\n            \"coverage_percentage\": percentage,\n            \"lines_covered\": 0,\n            \"lines_total\": 0,\n            \"branches_covered\": 0,\n            \"branches_total\": 0,\n            \"uncovered_files\": [],\n            \"uncovered_lines\": {},\n            \"analysis_method\": \"pytest-output-parsing\"\n        }\n\n    # No coverage found\n    return {\n        \"coverage_percentage\": 0.0,\n        \"lines_covered\": 0,\n        \"lines_total\": 0,\n        \"branches_covered\": 0,\n        \"branches_total\": 0,\n        \"uncovered_files\": [],\n        \"uncovered_lines\": {},\n        \"analysis_method\": \"no-coverage-data\",\n        \"error\": \"Could not parse coverage from output\"\n    }\n\n\ndef _is_cache_valid(cached_context: Dict[str, Any]) -> bool:\n    \"\"\"\n    Check if cached coverage results are still valid.\n\n    Cache is valid if:\n    - No code changes since last run\n    - Less than 5 minutes old\n    \"\"\"\n    if \"timestamp\" not in cached_context:\n        return False\n\n    cached_time = datetime.fromisoformat(cached_context[\"timestamp\"])\n    age_seconds = (datetime.now() - cached_time).total_seconds()\n\n    # Cache expires after 5 minutes\n    if age_seconds > 300:\n        return False\n\n    # TODO: Check git diff to see if code changed\n    # For now, assume cache is valid if recent\n    return True\n\n\ndef _get_cached_context(\n    state: Dict[str, Any],\n    context_optimizer: Optional[Any]\n) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    Retrieve cached context from previous validations.\n    \"\"\"\n    if not context_optimizer:\n        return None\n\n    return context_optimizer.get_cached_coverage(\n        workflow_id=state.get(\"workflow_id\"),\n        gate_id=\"gate_2_coverage\"\n    )\n\n\ndef _calculate_cost(\n    coverage_result: Dict[str, Any],\n    context_optimizer: Optional[Any]\n) -> tuple[float, int]:\n    \"\"\"\n    Calculate cost of validation in USD and tokens used.\n\n    With context optimization:\n    - First run: ~2000 tokens, $0.03\n    - Cached runs: ~500 tokens, $0.01 (75% savings)\n    \"\"\"\n    base_tokens = 2000\n\n    if context_optimizer and _is_cache_valid(coverage_result):\n        # Cached result - significant savings\n        tokens = 500\n        cost = tokens * 0.000015  # $0.015 per 1K tokens (Claude Sonnet 4)\n    else:\n        # Full analysis\n        tokens = base_tokens\n        cost = tokens * 0.000015\n\n    return round(cost, 4), tokens\n\n\ndef _build_message(\n    passed: bool,\n    coverage_result: Dict[str, Any],\n    threshold: float\n) -> str:\n    \"\"\"\n    Build human-readable validation message.\n    \"\"\"\n    percentage = coverage_result.get(\"coverage_percentage\", 0)\n\n    if passed:\n        return f\"✓ Coverage validation passed: {percentage}% (threshold: {threshold}%)\"\n\n    uncovered_count = len(coverage_result.get(\"uncovered_files\", []))\n    return (\n        f\"✗ Coverage validation failed: {percentage}% < {threshold}% \"\n        f\"({uncovered_count} files need coverage)\"\n    )\n\n\ndef _suggest_actions(coverage_result: Dict[str, Any]) -> list[str]:\n    \"\"\"\n    Suggest remediation actions based on coverage gaps.\n    \"\"\"\n    actions = []\n\n    uncovered_files = coverage_result.get(\"uncovered_files\", [])\n    if uncovered_files:\n        actions.append(f\"Add tests for {len(uncovered_files)} uncovered files\")\n        actions.append(f\"Focus on: {', '.join(uncovered_files[:3])}\")\n\n    uncovered_lines = coverage_result.get(\"uncovered_lines\", {})\n    if uncovered_lines:\n        for filepath, lines in list(uncovered_lines.items())[:3]:\n            actions.append(f\"Cover lines {lines[:5]} in {filepath}\")\n\n    if not actions:\n        actions.append(\"Review coverage report for gaps\")\n\n    return actions\n\n\ndef _error_result(gate_id: str, error_message: str, retry_count: int) -> ValidationResult:\n    \"\"\"\n    Build error result when validation fails unexpectedly.\n    \"\"\"\n    return {\n        \"gate_id\": gate_id,\n        \"passed\": False,\n        \"message\": f\"Validation error: {error_message}\",\n        \"details\": {\"error\": error_message},\n        \"retry_count\": retry_count,\n        \"timestamp\": datetime.now(),\n        \"cost\": 0.0,\n        \"tokens_used\": 0,\n        \"suggested_actions\": [\"Fix validation error\", \"Check test environment\"],\n        \"specialist_required\": True,\n        \"specialist_agent\": \"test-automation\"\n    }\n\n\ndef _coverage_timeout_result() -> Dict[str, Any]:\n    \"\"\"\n    Result when coverage analysis times out.\n    \"\"\"\n    return {\n        \"coverage_percentage\": 0.0,\n        \"lines_covered\": 0,\n        \"lines_total\": 0,\n        \"branches_covered\": 0,\n        \"branches_total\": 0,\n        \"uncovered_files\": [],\n        \"uncovered_lines\": {},\n        \"error\": \"Coverage analysis timed out (>5 minutes)\"\n    }\n\n\ndef _coverage_missing_tool_result() -> Dict[str, Any]:\n    \"\"\"\n    Result when pytest-cov is not installed.\n    \"\"\"\n    return {\n        \"coverage_percentage\": 0.0,\n        \"lines_covered\": 0,\n        \"lines_total\": 0,\n        \"branches_covered\": 0,\n        \"branches_total\": 0,\n        \"uncovered_files\": [],\n        \"uncovered_lines\": {},\n        \"error\": \"pytest-cov not installed - run: pip install pytest pytest-cov\"\n    }\n\n\ndef _coverage_error_result(error_message: str) -> Dict[str, Any]:\n    \"\"\"\n    Generic error result.\n    \"\"\"\n    return {\n        \"coverage_percentage\": 0.0,\n        \"lines_covered\": 0,\n        \"lines_total\": 0,\n        \"branches_covered\": 0,\n        \"branches_total\": 0,\n        \"uncovered_files\": [],\n        \"uncovered_lines\": {},\n        \"error\": error_message\n    }\n"}}
