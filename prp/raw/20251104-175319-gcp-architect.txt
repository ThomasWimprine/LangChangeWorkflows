I need to read the feature file first to understand what needs to be decomposed.

```json
{
    "agent": "gcp-architect",
    "atomicity": {
        "is_atomic": false,
        "reasons": [
            "Feature involves multiple distinct workflows (draft, generate, execute)",
            "Requires coordination across multiple specialized agents",
            "Involves complex state management and validation gates",
            "Contains infrastructure setup, API integration, and multiple validation layers"
        ]
    },
    "proposed_tasks": [
        {
            "id": "001",
            "agent": "python-developer",
            "objective": "Create PRPState TypedDict schema with all required state fields",
            "affected_components": [
                "src/schemas/prp_state.py"
            ],
            "dependencies": [],
            "acceptance": [
                "PRPState TypedDict defined with 15+ fields matching specification",
                "All fields properly typed (str, dict, list, bool, float)",
                "Schema includes gates_passed, gates_failed, cost_tracking dictionaries",
                "ValidationResult TypedDict defined with gate_id, passed, message, details",
                "100% test coverage with pytest"
            ],
            "risk": [
                "Type definition mismatches could cause runtime errors"
            ],
            "effort": "S"
        },
        {
            "id": "002",
            "agent": "python-developer",
            "objective": "Implement StateGraph initialization and basic node structure",
            "affected_components": [
                "src/workflows/base_prp_workflow.py"
            ],
            "dependencies": [
                "001"
            ],
            "acceptance": [
                "StateGraph created with PRPState schema",
                "Initialize node implemented and registered",
                "Entry point configured to initialize node",
                "Graph compiles without errors",
                "100% test coverage with unit tests"
            ],
            "risk": [
                "Graph compilation failures if schema incorrect"
            ],
            "effort": "M"
        },
        {
            "id": "003",
            "agent": "python-developer",
            "objective": "Create context optimization module for API prompt caching",
            "affected_components": [
                "src/utils/context_optimizer.py"
            ],
            "dependencies": [],
            "acceptance": [
                "ContextOptimizer class with cache_prompt and get_cached_prompt methods",
                "LRU cache implementation with 100 entry limit",
                "Cache hit/miss tracking in state",
                "40% token reduction verified in tests",
                "100% test coverage"
            ],
            "risk": [
                "Cache invalidation logic may need tuning"
            ],
            "effort": "M"
        },
        {
            "id": "004",
            "agent": "python-developer",
            "objective": "Implement Gate 2 coverage validation node",
            "affected_components": [
                "src/gates/gate2_coverage.py"
            ],
            "dependencies": [
                "001"
            ],
            "acceptance": [
                "validate_coverage_gate function runs pytest with coverage",
                "Parses coverage.json and validates >= 100%",
                "Returns ValidationResult with pass/fail status",
                "Tracks cost and tokens in result",
                "100% test coverage with mocked pytest execution"
            ],
            "risk": [
                "pytest coverage plugin must be available"
            ],
            "effort": "M"
        },
        {
            "id": "005",
            "agent": "python-developer",
            "objective": "Add conditional routing logic for gate results",
            "affected_components": [
                "src/workflows/base_prp_workflow.py"
            ],
            "dependencies": [
                "002",
                "004"
            ],
            "acceptance": [
                "route_gate_result function checks validation result passed field",
                "Routes to workflow_success on pass",
                "Routes to handle_failure on fail with retries remaining",
                "Routes to circuit_breaker on 15 consecutive failures",
                "100% test coverage with all routing paths"
            ],
            "risk": [
                "Incorrect routing could bypass validation"
            ],
            "effort": "S"
        },
        {
            "id": "006",
            "agent": "python-developer",
            "objective": "Implement handle_failure node with 3-strike retry logic",
            "affected_components": [
                "src/workflows/base_prp_workflow.py"
            ],
            "dependencies": [
                "002"
            ],
            "acceptance": [
                "Increments gates_failed counter for current gate",
                "Increments consecutive_failures counter",
                "Consults specialist after 3 failures per gate",
                "Triggers circuit breaker at 15 total failures",
                "100% test coverage with retry scenarios"
            ],
            "risk": [
                "Specialist consultation integration complexity"
            ],
            "effort": "M"
        },
        {
            "id": "007",
            "agent": "python-developer",
            "objective": "Create agent coordinator for specialist consultation",
            "affected_components": [
                "src/utils/agent_coordinator.py"
            ],
            "dependencies": [],
            "acceptance": [
                "AgentCoordinator class with consult_specialist method",
                "Maps gate IDs to specialist agents (test-automation, security-reviewer)",
                "Constructs specialist prompt with failure context",
                "Returns specialist recommendations as dict",
                "100% test coverage with mocked agent calls"
            ],
            "risk": [
                "Agent availability and response time variability"
            ],
            "effort": "M"
        },
        {
            "id": "008",
            "agent": "python-developer",
            "objective": "Implement workflow_success and circuit_breaker terminal nodes",
            "affected_components": [
                "src/workflows/base_prp_workflow.py"
            ],
            "dependencies": [
                "002"
            ],
            "acceptance": [
                "workflow_success sets status to completed and returns final state",
                "circuit_breaker sets status to failed with reason",
                "Both nodes are properly registered as END nodes",
                "State immutability maintained",
                "100% test coverage"
            ],
            "risk": [
                "None - terminal nodes are straightforward"
            ],
            "effort": "S"
        },
        {
            "id": "009",
            "agent": "python-developer",
            "objective": "Add checkpointing capability with MemorySaver",
            "affected_components": [
                "src/workflows/base_prp_workflow.py"
            ],
            "dependencies": [
                "002"
            ],
            "acceptance": [
                "MemorySaver configured as checkpointer",
                "State persisted after each node execution",
                "Resume capability from workflow_id implemented",
                "get_state method returns current state snapshot",
                "100% test coverage with checkpoint/resume scenarios"
            ],
            "risk": [
                "Memory usage for large state objects"
            ],
            "effort": "M"
        },
        {
            "id": "010",
            "agent": "python-developer",
            "objective": "Create cost tracking utilities and reporting",
            "affected_components": [
                "src/utils/cost_tracker.py"
            ],
            "dependencies": [],
            "acceptance": [
                "CostTracker class aggregates costs from state",
                "Calculate total workflow cost from all gates",
                "Compare cached vs uncached token usage",
                "Generate cost report with breakdown by gate",
                "100% test coverage"
            ],
            "risk": [
                "Cost calculation accuracy depends on accurate token counting"
            ],
            "effort": "S"
        },
        {
            "id": "011",
            "agent": "test-automation",
            "objective": "Create integration tests for complete workflow execution",
            "affected_components": [
                "tests/integration/test_workflow.py"
            ],
            "dependencies": [
                "002",
                "004",
                "005",
                "006",
                "008",
                "009"
            ],
            "acceptance": [
                "Test successful workflow with passing gates",
                "Test workflow with failures and retries",
                "Test circuit breaker activation",
                "Test checkpoint/resume functionality",
                "100% coverage of workflow execution paths"
            ],
            "risk": [
                "Integration tests may be slow"
            ],
            "effort": "L"
        },
        {
            "id": "012",
            "agent": "documentation-writer",
            "objective": "Create comprehensive workflow documentation",
            "affected_components": [
                "docs/WORKFLOW_GUIDE.md"
            ],
            "dependencies": [
                "011"
            ],
            "acceptance": [
                "Architecture overview with state flow diagrams",
                "API reference for all public classes and methods",
                "Usage examples for basic and advanced scenarios",
                "Troubleshooting guide with common issues",
                "Cost optimization tips documented"
            ],
            "risk": [
                "None - documentation is final step"
            ],
            "effort": "M"
        }
    ],
    "split_recommendation": [
        {
            "t-001": "Core state schema and type definitions"
        },
        {
            "t-002": "StateGraph infrastructure and node registration"
        },
        {
            "t-003": "Context caching for cost optimization"
        },
        {
            "t-004": "Gate validation implementation"
        },
        {
            "t-005": "Routing logic between nodes"
        },
        {
            "t-006": "Failure handling and retry mechanism"
        },
        {
            "t-007": "Specialist agent coordination"
        },
        {
            "t-008": "Terminal node implementations"
        },
        {
            "t-009": "Checkpointing and resume capability"
        },
        {
            "t-010": "Cost tracking and reporting"
        },
        {
            "t-011": "Integration testing"
        },
        {
            "t-012": "Documentation"
        }
    ],
    "delegation_suggestions": [
        {
            "python-developer": "Primary implementation for StateGraph, nodes, schemas, and utilities"
        },
        {
            "test-automation": "Integration test suite covering all workflow paths"
        },
        {
            "documentation-writer": "Comprehensive workflow documentation and guides"
        },
        {
            "architect-reviewer": "Review overall workflow architecture and node design before implementation"
        },
        {
            "security-reviewer": "Review cost tracking and state management for sensitive data handling"
        }
    ],
    "Questions": [
        {
            "agent": "architect-reviewer",
            "question": "Should we implement all 6 gates initially or start with Gate 2 as proof of concept?"
        },
        {
            "agent": "python-developer",
            "question": "What is the expected maximum state size for checkpointing memory limits?"
        },
        {
            "agent": "test-automation",
            "question": "Should integration tests mock external agent calls or require real agent availability?"
        },
        {
            "agent": "security-reviewer",
            "question": "Does state contain any sensitive data requiring encryption in checkpoints?"
        },
        {
            "agent": "documentation-writer",
            "question": "Should documentation include comparison to POC scripts from docs/POC_COMPARISON.md?"
        }
    ]
}
```