I need to read the feature file first to understand what needs to be decomposed.

```json
{
    "agent": "performance-profiler",
    "atomicity": {
        "is_atomic": false,
        "reasons": [
            "Feature involves multiple LangGraph lessons spanning 10+ distinct learning modules",
            "Requires both theoretical understanding and practical implementation across different concepts",
            "Dependencies span from basic setup through advanced multi-agent coordination",
            "Each lesson builds on previous lessons creating sequential dependencies",
            "Multiple technology domains: Python, LangGraph, Claude API, state management, etc."
        ]
    },
    "proposed_tasks": [
        {
            "id": "001",
            "agent": "python-developer",
            "objective": "Complete Lesson 01 - Build simplest 2-node LangGraph workflow (greetâ†’farewell)",
            "affected_components": [
                "lessons/01-hello-langgraph/"
            ],
            "dependencies": [],
            "acceptance": [
                "Two-node workflow executes successfully with greet and farewell nodes",
                "State flows correctly between nodes with message accumulation",
                "Example runs without errors and produces expected output",
                "README documents the workflow structure and key concepts learned",
                "Code includes comments explaining LangGraph basics"
            ],
            "risk": [
                "First exposure to LangGraph API may require iteration",
                "Understanding state management concept is foundational"
            ],
            "effort": "S"
        },
        {
            "id": "002",
            "agent": "python-developer",
            "objective": "Complete Lesson 02 - Implement complex state management with TypedDict schemas",
            "affected_components": [
                "lessons/02-state-management/"
            ],
            "dependencies": [],
            "acceptance": [
                "TypedDict schema defined with multiple field types",
                "State correctly typed and validated throughout workflow",
                "Demonstrates state updates, additions, and transformations",
                "Examples show common state patterns (counters, lists, nested objects)",
                "Documentation explains state schema design principles"
            ],
            "risk": [
                "Type system understanding required",
                "State immutability concepts may need clarification"
            ],
            "effort": "M"
        },
        {
            "id": "003",
            "agent": "python-developer",
            "objective": "Complete Lesson 03 - Implement conditional routing with if/then logic",
            "affected_components": [
                "lessons/03-conditional-routing/"
            ],
            "dependencies": [],
            "acceptance": [
                "Conditional edges implemented based on state values",
                "Multiple routing paths demonstrate different conditions",
                "Edge functions return correct target node names",
                "Workflow handles all routing scenarios without errors",
                "Documentation explains routing logic and decision points"
            ],
            "risk": [
                "Edge function signatures must match LangGraph expectations",
                "Routing logic complexity can grow quickly"
            ],
            "effort": "M"
        },
        {
            "id": "004",
            "agent": "python-developer",
            "objective": "Complete Lesson 04 - Implement retry patterns with failure handling",
            "affected_components": [
                "lessons/04-retry-patterns/"
            ],
            "dependencies": [],
            "acceptance": [
                "Retry logic handles transient failures (3-strike rule)",
                "State tracks retry counts and failure history",
                "Circuit breaker pattern prevents infinite retries",
                "Failed operations log appropriately and gracefully degrade",
                "Examples demonstrate retry scenarios with mock failures"
            ],
            "risk": [
                "Retry state management can introduce complexity",
                "Need to balance retry attempts with performance"
            ],
            "effort": "M"
        },
        {
            "id": "005",
            "agent": "python-developer",
            "objective": "Complete Lesson 05 - Integrate Claude API calls from workflow nodes",
            "affected_components": [
                "lessons/05-claude-api/"
            ],
            "dependencies": [],
            "acceptance": [
                "Anthropic SDK integrated and API key configured",
                "Node functions successfully call Claude API",
                "API responses parsed and added to state",
                "Error handling for API failures implemented",
                "Cost tracking for API calls demonstrated"
            ],
            "risk": [
                "API key management and security considerations",
                "Rate limiting and API quota awareness needed"
            ],
            "effort": "M"
        },
        {
            "id": "006",
            "agent": "python-developer",
            "objective": "Complete Lesson 06 - Build multi-node workflow with validation gates",
            "affected_components": [
                "lessons/06-multi-node/"
            ],
            "dependencies": [],
            "acceptance": [
                "Workflow contains 3+ validation gate nodes",
                "Gates validate different aspects (coverage, mocks, security)",
                "Conditional routing between gates based on validation results",
                "State tracks which gates passed/failed",
                "Example demonstrates complete gate execution flow"
            ],
            "risk": [
                "Gate coordination complexity increases with more nodes",
                "State management becomes more complex"
            ],
            "effort": "L"
        },
        {
            "id": "007",
            "agent": "python-developer",
            "objective": "Complete Lesson 07 - Implement cost optimization with context caching",
            "affected_components": [
                "lessons/07-cost-optimization/"
            ],
            "dependencies": [],
            "acceptance": [
                "Context caching implemented for repeated API calls",
                "Cost tracking shows 30-50% reduction on retries",
                "Cache hits/misses logged and reported",
                "Documentation explains caching strategy and benefits",
                "Examples demonstrate cost savings with metrics"
            ],
            "risk": [
                "Cache invalidation strategy needed",
                "Must balance cache memory usage with savings"
            ],
            "effort": "M"
        },
        {
            "id": "008",
            "agent": "python-developer",
            "objective": "Complete Lesson 08 - Implement multi-agent coordination and specialist consultation",
            "affected_components": [
                "lessons/08-multi-agent/"
            ],
            "dependencies": [],
            "acceptance": [
                "Multiple specialist agents integrated (test-automation, security-reviewer, etc.)",
                "Agent consultation triggered after 3 failures per gate",
                "Agent recommendations incorporated into workflow state",
                "Specialist responses parsed and actionable",
                "Documentation explains agent coordination patterns"
            ],
            "risk": [
                "Agent coordination adds significant complexity",
                "Managing multiple agent contexts requires careful design"
            ],
            "effort": "L"
        },
        {
            "id": "009",
            "agent": "python-developer",
            "objective": "Complete Lesson 09 - Implement complete PRP workflow with all 6 gates",
            "affected_components": [
                "lessons/09-complete-prp/"
            ],
            "dependencies": [],
            "acceptance": [
                "All 6 validation gates implemented (TDD, coverage, mocks, mutation, security, production-ready)",
                "Complete workflow executes end-to-end successfully",
                "Retry logic, circuit breakers, and specialist consultation working",
                "State management handles all gates and transitions",
                "Cost tracking shows optimization from caching"
            ],
            "risk": [
                "Integration of all previous lessons into cohesive workflow",
                "Performance and reliability at full scale"
            ],
            "effort": "L"
        },
        {
            "id": "010",
            "agent": "python-developer",
            "objective": "Complete Lesson 10 - Deploy workflow to production with monitoring",
            "affected_components": [
                "lessons/10-production/"
            ],
            "dependencies": [],
            "acceptance": [
                "Workflow deployed to production environment",
                "Monitoring and alerting configured",
                "Production configuration separate from development",
                "Documentation includes deployment procedures",
                "Smoke tests verify production deployment"
            ],
            "risk": [
                "Production environment differences may cause issues",
                "Monitoring setup complexity"
            ],
            "effort": "M"
        }
    ],
    "split_recommendation": [
        {
            "t-001": "Foundational lesson - start here to understand LangGraph basics before proceeding"
        },
        {
            "t-002": "Build on Lesson 01 understanding, can be done independently once basics are understood"
        },
        {
            "t-003": "Conditional routing builds on state management concepts from Lesson 02"
        },
        {
            "t-004": "Retry patterns are independent but benefit from understanding state and routing"
        },
        {
            "t-005": "Claude API integration is independent and can be developed in parallel"
        },
        {
            "t-006": "Combines concepts from Lessons 02-05, should be done after those are complete"
        },
        {
            "t-007": "Cost optimization should be done after API integration is working"
        },
        {
            "t-008": "Multi-agent coordination requires solid understanding of all previous lessons"
        },
        {
            "t-009": "Final integration lesson, requires all previous lessons complete"
        },
        {
            "t-010": "Production deployment is final step after complete implementation"
        }
    ],
    "delegation_suggestions": [
        {
            "documentation-writer": "Create comprehensive learning materials and README files for each lesson"
        },
        {
            "test-automation": "Develop test suites for each lesson to verify learning objectives"
        },
        {
            "architect-reviewer": "Review overall lesson structure and learning path progression"
        }
    ],
    "Questions": [
        {
            "agent": "performance-profiler",
            "question": "Should lessons 02-05 be done sequentially or can they be parallelized since they cover independent concepts?"
        },
        {
            "agent": "performance-profiler",
            "question": "Is there a specific deadline or timeline for completing all 10 lessons?"
        },
        {
            "agent": "performance-profiler",
            "question": "Should each lesson include hands-on exercises beyond the basic implementation?"
        },
        {
            "agent": "performance-profiler",
            "question": "Are there specific performance benchmarks expected for the final PRP workflow?"
        }
    ]
}
```